
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples/compute_kinematics.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_examples_compute_kinematics.py>`
        to download the full example code or to run this example in your browser via Binder

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_compute_kinematics.py:


Compute and visualise kinematics
=================================

Compute displacement, velocity and acceleration data on an example dataset and
visualise the results.

.. GENERATED FROM PYTHON SOURCE LINES 11-13

Imports
-------

.. GENERATED FROM PYTHON SOURCE LINES 13-23

.. code-block:: Python


    import numpy as np

    # For interactive plots: install ipympl with `pip install ipympl` and uncomment
    # the following line in your notebook
    # %matplotlib widget
    from matplotlib import pyplot as plt

    from movement import sample_data








.. GENERATED FROM PYTHON SOURCE LINES 24-28

Load sample dataset
------------------------
First, we load an example dataset. In this case, we select the
``SLEAP_three-mice_Aeon_proofread`` sample data.

.. GENERATED FROM PYTHON SOURCE LINES 28-34

.. code-block:: Python

    ds = sample_data.fetch_sample_data(
        "SLEAP_three-mice_Aeon_proofread.analysis.h5",
    )

    print(ds)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    <xarray.Dataset> Size: 27kB
    Dimensions:      (time: 601, individuals: 3, keypoints: 1, space: 2)
    Coordinates:
      * time         (time) float64 5kB 0.0 0.02 0.04 0.06 ... 11.96 11.98 12.0
      * individuals  (individuals) <U10 120B 'AEON3B_NTP' 'AEON3B_TP1' 'AEON3B_TP2'
      * keypoints    (keypoints) <U8 32B 'centroid'
      * space        (space) <U1 8B 'x' 'y'
    Data variables:
        pose_tracks  (time, individuals, keypoints, space) float32 14kB 770.3 ......
        confidence   (time, individuals, keypoints) float32 7kB nan nan ... nan nan
    Attributes:
        fps:              50.0
        time_unit:        seconds
        source_software:  SLEAP
        source_file:      /home/runner/.movement/data/poses/SLEAP_three-mice_Aeon...




.. GENERATED FROM PYTHON SOURCE LINES 35-40

We can see in the printed description of the dataset ``ds`` that
the data was acquired at 50 fps, and the time axis is expressed in seconds.
It includes data for three individuals(``AEON3B_NTP``, ``AEON3B_TP1``,
and ``AEON3B_TP2``), and only one keypoint called ``centroid`` was tracked
in ``x`` and ``y`` dimensions.

.. GENERATED FROM PYTHON SOURCE LINES 42-46

The loaded dataset ``ds`` contains two data arrays:
``pose_tracks`` and ``confidence``.
To compute displacement, velocity and acceleration, we will need the pose
tracks one:

.. GENERATED FROM PYTHON SOURCE LINES 46-49

.. code-block:: Python

    pose_tracks = ds.pose_tracks









.. GENERATED FROM PYTHON SOURCE LINES 50-54

Visualise the data
---------------------------
First, let's visualise the trajectories of the mice in the XY plane,
colouring them by individual.

.. GENERATED FROM PYTHON SOURCE LINES 54-73

.. code-block:: Python


    fig, ax = plt.subplots(1, 1)
    for mouse_name, col in zip(pose_tracks.individuals.values, ["r", "g", "b"]):
        ax.plot(
            pose_tracks.sel(individuals=mouse_name, space="x"),
            pose_tracks.sel(individuals=mouse_name, space="y"),
            linestyle="-",
            marker=".",
            markersize=2,
            linewidth=0.5,
            c=col,
            label=mouse_name,
        )
        ax.invert_yaxis()
        ax.set_xlabel("x (pixels)")
        ax.set_ylabel("y (pixels)")
        ax.axis("equal")
        ax.legend()




.. image-sg:: /examples/images/sphx_glr_compute_kinematics_001.png
   :alt: compute kinematics
   :srcset: /examples/images/sphx_glr_compute_kinematics_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 74-78

We can see that the trajectories of the three mice are close to a circular
arc. Notice that the x and y axes are set to equal scales, and that the
origin of the coordinate system is at the top left of the image. This
follows the convention for SLEAP and most image processing tools.

.. GENERATED FROM PYTHON SOURCE LINES 80-81

We can also color the data points based on their timestamps:

.. GENERATED FROM PYTHON SOURCE LINES 81-98

.. code-block:: Python

    fig, axes = plt.subplots(3, 1, sharey=True)
    for mouse_name, ax in zip(pose_tracks.individuals.values, axes):
        sc = ax.scatter(
            pose_tracks.sel(individuals=mouse_name, space="x"),
            pose_tracks.sel(individuals=mouse_name, space="y"),
            s=2,
            c=pose_tracks.time,
            cmap="viridis",
        )
        ax.invert_yaxis()
        ax.set_title(mouse_name)
        ax.set_xlabel("x (pixels)")
        ax.set_ylabel("y (pixels)")
        ax.axis("equal")
        fig.colorbar(sc, ax=ax, label="time (s)")
    fig.tight_layout()




.. image-sg:: /examples/images/sphx_glr_compute_kinematics_002.png
   :alt: AEON3B_NTP, AEON3B_TP1, AEON3B_TP2
   :srcset: /examples/images/sphx_glr_compute_kinematics_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 99-103

These plots show that for this snippet of the data,
two of the mice (``AEON3B_NTP`` and ``AEON3B_TP1``)
moved around the circle in clockwise direction, and
the third mouse (``AEON3B_TP2``) followed an anti-clockwise direction.

.. GENERATED FROM PYTHON SOURCE LINES 105-108

We can also easily plot the components of the position vector against time
using ``xarray``'s built-in plotting methods. We use ``squeeze()`` to
remove the dimension of length 1 from the data (the keypoints dimension).

.. GENERATED FROM PYTHON SOURCE LINES 108-113

.. code-block:: Python

    pose_tracks.squeeze().plot.line(
        x="time", row="individuals", aspect=2, size=2.5
    )
    plt.gcf().show()




.. image-sg:: /examples/images/sphx_glr_compute_kinematics_003.png
   :alt: individuals = AEON3B_NTP, individuals = AEON3B_TP1, individuals = AEON3B_TP2
   :srcset: /examples/images/sphx_glr_compute_kinematics_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 114-117

If we use ``xarray``'s plotting function, the axes units are automatically
taken from the data array. In our case, ``time`` is expressed in seconds,
and the ``x`` and ``y`` coordinates of the ``pose_tracks`` are in pixels.

.. GENERATED FROM PYTHON SOURCE LINES 119-124

Compute displacement
---------------------
We can start off by computing the distance travelled by the mice along
their trajectories.
For this, we can use the ``displacement`` method of the ``move`` accessor.

.. GENERATED FROM PYTHON SOURCE LINES 124-126

.. code-block:: Python

    displacement = ds.move.displacement








.. GENERATED FROM PYTHON SOURCE LINES 127-130

This method will return a data array equivalent to the ``pose_tracks`` one,
but holding displacement data along the ``space`` axis, rather than
position data.

.. GENERATED FROM PYTHON SOURCE LINES 132-134

Notice that we could also compute the displacement (and all the other
kinematic variables) using the kinematics module:

.. GENERATED FROM PYTHON SOURCE LINES 136-140

.. code-block:: Python

    import movement.analysis.kinematics as kin

    displacement_kin = kin.compute_displacement(pose_tracks)








.. GENERATED FROM PYTHON SOURCE LINES 141-147

However, we encourage our users to familiarise themselves with the ``move``
accessor, since it has a very interesting advantage: if we use
``ds.move.displacement`` to compute the displacement data array, it
will be automatically added to the ``ds`` dataset. This is very
convenient for later analyses!
See further details in :ref:`target-access-kinematics`.

.. GENERATED FROM PYTHON SOURCE LINES 149-152

The ``displacement`` data array holds, for a given individual and keypoint
at timestep ``t``, the vector that goes from its previous position at time
``t-1`` to its current position at time ``t``.

.. GENERATED FROM PYTHON SOURCE LINES 154-158

And what happens at ``t=0``, since there is no previous timestep?
We define the displacement vector at time ``t=0`` to be the zero vector.
This way the shape of the ``displacement`` data array is the
same as the  ``pose_tracks`` array:

.. GENERATED FROM PYTHON SOURCE LINES 158-161

.. code-block:: Python

    print(f"Shape of pose_tracks: {pose_tracks.shape}")
    print(f"Shape of pose_tracks_displacement: {displacement.shape}")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Shape of pose_tracks: (601, 3, 1, 2)
    Shape of pose_tracks_displacement: (601, 3, 1, 2)




.. GENERATED FROM PYTHON SOURCE LINES 162-164

We can visualise these displacement vectors with a quiver plot. In this case
we focus on the mouse ``AEON3B_TP2``:

.. GENERATED FROM PYTHON SOURCE LINES 164-201

.. code-block:: Python

    mouse_name = "AEON3B_TP2"

    fig = plt.figure()
    ax = fig.add_subplot()

    # plot position data
    sc = ax.scatter(
        pose_tracks.sel(individuals=mouse_name, space="x"),
        pose_tracks.sel(individuals=mouse_name, space="y"),
        s=15,
        c=pose_tracks.time,
        cmap="viridis",
    )

    # plot displacement vectors: at t, vector from t-1 to t
    ax.quiver(
        pose_tracks.sel(individuals=mouse_name, space="x"),
        pose_tracks.sel(individuals=mouse_name, space="y"),
        displacement.sel(individuals=mouse_name, space="x"),
        displacement.sel(individuals=mouse_name, space="y"),
        angles="xy",
        scale=1,
        scale_units="xy",
        headwidth=7,
        headlength=9,
        headaxislength=9,
    )

    ax.axis("equal")
    ax.set_xlim(450, 575)
    ax.set_ylim(950, 1075)
    ax.set_xlabel("x (pixels)")
    ax.set_ylabel("y (pixels)")
    ax.set_title(f"Zoomed in trajectory of {mouse_name}")
    ax.invert_yaxis()
    fig.colorbar(sc, ax=ax, label="time (s)")




.. image-sg:: /examples/images/sphx_glr_compute_kinematics_004.png
   :alt: Zoomed in trajectory of AEON3B_TP2
   :srcset: /examples/images/sphx_glr_compute_kinematics_004.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <matplotlib.colorbar.Colorbar object at 0x735ccea5e350>



.. GENERATED FROM PYTHON SOURCE LINES 202-206

Notice that this figure is not very useful as a visual check:
we can see that there are vectors defined for each point in
the trajectory, but we have no easy way to verify they are indeed
the displacement vectors from ``t-1`` to ``t``.

.. GENERATED FROM PYTHON SOURCE LINES 208-215

If instead we plot
the opposite of the displacement vector, we will see that at every time
``t``, the vectors point to the position at ``t-1``.
Remember that the displacement vector is defined as the vector at
time ``t``, that goes from the previous position ``t-1`` to the
current position at ``t``. Therefore, the opposite vector will point
from the position point at ``t``, to the position point at ``t-1``.

.. GENERATED FROM PYTHON SOURCE LINES 217-219

We can easily do this by flipping the sign of the displacement vector in
the plot above:

.. GENERATED FROM PYTHON SOURCE LINES 219-256

.. code-block:: Python

    mouse_name = "AEON3B_TP2"

    fig = plt.figure()
    ax = fig.add_subplot()

    # plot position data
    sc = ax.scatter(
        pose_tracks.sel(individuals=mouse_name, space="x"),
        pose_tracks.sel(individuals=mouse_name, space="y"),
        s=15,
        c=pose_tracks.time,
        cmap="viridis",
    )

    # plot displacement vectors: at t, vector from t-1 to t
    ax.quiver(
        pose_tracks.sel(individuals=mouse_name, space="x"),
        pose_tracks.sel(individuals=mouse_name, space="y"),
        -displacement.sel(individuals=mouse_name, space="x"),  # flipped sign
        -displacement.sel(individuals=mouse_name, space="y"),  # flipped sign
        angles="xy",
        scale=1,
        scale_units="xy",
        headwidth=7,
        headlength=9,
        headaxislength=9,
    )
    ax.axis("equal")
    ax.set_xlim(450, 575)
    ax.set_ylim(950, 1075)
    ax.set_xlabel("x (pixels)")
    ax.set_ylabel("y (pixels)")
    ax.set_title(f"Zoomed in trajectory of {mouse_name}")
    ax.invert_yaxis()
    fig.colorbar(sc, ax=ax, label="time (s)")





.. image-sg:: /examples/images/sphx_glr_compute_kinematics_005.png
   :alt: Zoomed in trajectory of AEON3B_TP2
   :srcset: /examples/images/sphx_glr_compute_kinematics_005.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <matplotlib.colorbar.Colorbar object at 0x735cce946350>



.. GENERATED FROM PYTHON SOURCE LINES 257-259

Now we can visually verify that indeed the displacement vector
connects the previous and current positions as expected.

.. GENERATED FROM PYTHON SOURCE LINES 261-263

With the displacement data we can compute the distance travelled by the
mouse along its trajectory.

.. GENERATED FROM PYTHON SOURCE LINES 263-278

.. code-block:: Python


    # length of each displacement vector
    displacement_vectors_lengths = np.linalg.norm(
        displacement.sel(individuals=mouse_name, space=["x", "y"]).squeeze(),
        axis=1,
    )

    # sum of all displacement vectors
    total_displacement = np.sum(displacement_vectors_lengths, axis=0)  # in pixels

    print(
        f"The mouse {mouse_name}'s trajectory is {total_displacement:.2f} "
        "pixels long"
    )





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    The mouse AEON3B_TP2's trajectory is 1640.09 pixels long




.. GENERATED FROM PYTHON SOURCE LINES 279-283

Compute velocity
----------------
We can easily compute the velocity vectors for all individuals in our data
array:

.. GENERATED FROM PYTHON SOURCE LINES 283-285

.. code-block:: Python

    velocity = ds.move.velocity








.. GENERATED FROM PYTHON SOURCE LINES 286-290

The ``velocity`` method will return a data array equivalent to the
pose_tracks one, but holding velocity data along the ``space`` axis, rather
than position data. Notice how ``xarray`` nicely deals with the different
individuals and spatial dimensions for us! ✨

.. GENERATED FROM PYTHON SOURCE LINES 292-295

We can plot the components of the velocity vector against time
using ``xarray``'s built-in plotting methods. We use ``squeeze()`` to
remove the dimension of length 1 from the data (the keypoints dimension).

.. GENERATED FROM PYTHON SOURCE LINES 295-299

.. code-block:: Python


    velocity.squeeze().plot.line(x="time", row="individuals", aspect=2, size=2.5)
    plt.gcf().show()




.. image-sg:: /examples/images/sphx_glr_compute_kinematics_006.png
   :alt: individuals = AEON3B_NTP, individuals = AEON3B_TP1, individuals = AEON3B_TP2
   :srcset: /examples/images/sphx_glr_compute_kinematics_006.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 300-306

The components of the velocity vector seem noisier than the components of
the position vector.
This is expected, since we are deriving the velocity using differences in
position (which is somewhat noisy), over small stepsizes.
More specifically, we use numpy's gradient implementation, which
uses second order central differences.

.. GENERATED FROM PYTHON SOURCE LINES 308-309

We can also visualise the speed, as the norm of the velocity vector:

.. GENERATED FROM PYTHON SOURCE LINES 309-323

.. code-block:: Python

    fig, axes = plt.subplots(3, 1, sharex=True, sharey=True)
    for mouse_name, ax in zip(velocity.individuals.values, axes):
        # compute the norm of the velocity vector for one mouse
        speed_one_mouse = np.linalg.norm(
            velocity.sel(individuals=mouse_name, space=["x", "y"]).squeeze(),
            axis=1,
        )
        # plot speed against time
        ax.plot(speed_one_mouse)
        ax.set_title(mouse_name)
        ax.set_xlabel("time (s)")
        ax.set_ylabel("speed (px/s)")
    fig.tight_layout()




.. image-sg:: /examples/images/sphx_glr_compute_kinematics_007.png
   :alt: AEON3B_NTP, AEON3B_TP1, AEON3B_TP2
   :srcset: /examples/images/sphx_glr_compute_kinematics_007.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 324-326

To visualise the direction of the velocity vector at each timestep, we can
use a quiver plot:

.. GENERATED FROM PYTHON SOURCE LINES 326-356

.. code-block:: Python

    mouse_name = "AEON3B_TP2"
    fig = plt.figure()
    ax = fig.add_subplot()
    # plot trajectory (position data)
    sc = ax.scatter(
        pose_tracks.sel(individuals=mouse_name, space="x"),
        pose_tracks.sel(individuals=mouse_name, space="y"),
        s=15,
        c=pose_tracks.time,
        cmap="viridis",
    )
    # plot velocity vectors
    ax.quiver(
        pose_tracks.sel(individuals=mouse_name, space="x"),
        pose_tracks.sel(individuals=mouse_name, space="y"),
        velocity.sel(individuals=mouse_name, space="x"),
        velocity.sel(individuals=mouse_name, space="y"),
        angles="xy",
        scale=2,
        scale_units="xy",
        color="r",
    )
    ax.axis("equal")
    ax.set_xlabel("x (pixels)")
    ax.set_ylabel("y (pixels)")
    ax.set_title(f"Velocity quiver plot for {mouse_name}")
    ax.invert_yaxis()
    fig.colorbar(sc, ax=ax, label="time (s)")
    fig.show()




.. image-sg:: /examples/images/sphx_glr_compute_kinematics_008.png
   :alt: Velocity quiver plot for AEON3B_TP2
   :srcset: /examples/images/sphx_glr_compute_kinematics_008.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 357-359

Here we scaled the length of vectors to half of their actual value
(``scale=2``) for easier visualisation.

.. GENERATED FROM PYTHON SOURCE LINES 361-364

Compute acceleration
---------------------
We can compute the acceleration of the data with an equivalent method:

.. GENERATED FROM PYTHON SOURCE LINES 364-366

.. code-block:: Python

    accel = ds.move.acceleration








.. GENERATED FROM PYTHON SOURCE LINES 367-369

and plot of the components of the acceleration vector ``ax``, ``ay`` per
individual:

.. GENERATED FROM PYTHON SOURCE LINES 369-387

.. code-block:: Python

    fig, axes = plt.subplots(3, 1, sharex=True, sharey=True)
    for mouse_name, ax in zip(accel.individuals.values, axes):
        # plot x-component of acceleration vector
        ax.plot(
            accel.sel(individuals=mouse_name, space=["x"]).squeeze(),
            label="ax",
        )
        # plot y-component of acceleration vector
        ax.plot(
            accel.sel(individuals=mouse_name, space=["y"]).squeeze(),
            label="ay",
        )
        ax.set_title(mouse_name)
        ax.set_xlabel("time (s)")
        ax.set_ylabel("speed (px/s**2)")
        ax.legend(loc="center right", bbox_to_anchor=(1.07, 1.07))
    fig.tight_layout()




.. image-sg:: /examples/images/sphx_glr_compute_kinematics_009.png
   :alt: AEON3B_NTP, AEON3B_TP1, AEON3B_TP2
   :srcset: /examples/images/sphx_glr_compute_kinematics_009.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 388-391

The norm of the acceleration vector is the magnitude of the
acceleration.
We can also represent this for each individual.

.. GENERATED FROM PYTHON SOURCE LINES 391-407

.. code-block:: Python

    fig, axes = plt.subplots(3, 1, sharex=True, sharey=True)
    for mouse_name, ax in zip(accel.individuals.values, axes):
        # compute norm of the acceleration vector for one mouse
        accel_one_mouse = np.linalg.norm(
            accel.sel(individuals=mouse_name, space=["x", "y"]).squeeze(),
            axis=1,
        )

        # plot acceleration against time
        ax.plot(accel_one_mouse)
        ax.set_title(mouse_name)
        ax.set_xlabel("time (s)")
        ax.set_ylabel("accel (px/s**2)")
    fig.tight_layout()





.. image-sg:: /examples/images/sphx_glr_compute_kinematics_010.png
   :alt: AEON3B_NTP, AEON3B_TP1, AEON3B_TP2
   :srcset: /examples/images/sphx_glr_compute_kinematics_010.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 408-418

.. _target-access-kinematics:

Accessing pre-computed kinematic variables
------------------------------------------
Once each kinematic variable has been computed via the ``move`` accessor,
(e.g. by calling ``ds.move.velocity``), the resulting data array will
also be available as a dataset property, (e.g. as ``ds.velocity``).
Since we've already computed ``displacement``, ``velocity`` and
``acceleration`` above, they should be listed among the data arrays
contained in the dataset:

.. GENERATED FROM PYTHON SOURCE LINES 418-420

.. code-block:: Python

    print(ds)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    <xarray.Dataset> Size: 70kB
    Dimensions:       (time: 601, individuals: 3, keypoints: 1, space: 2)
    Coordinates:
      * time          (time) float64 5kB 0.0 0.02 0.04 0.06 ... 11.96 11.98 12.0
      * individuals   (individuals) <U10 120B 'AEON3B_NTP' 'AEON3B_TP1' 'AEON3B_TP2'
      * keypoints     (keypoints) <U8 32B 'centroid'
      * space         (space) <U1 8B 'x' 'y'
    Data variables:
        pose_tracks   (time, individuals, keypoints, space) float32 14kB 770.3 .....
        confidence    (time, individuals, keypoints) float32 7kB nan nan ... nan nan
        displacement  (time, individuals, keypoints, space) float32 14kB 0.0 ... ...
        velocity      (time, individuals, keypoints, space) float32 14kB 150.8 .....
        acceleration  (time, individuals, keypoints, space) float32 14kB -3.704e+...
    Attributes:
        fps:              50.0
        time_unit:        seconds
        source_software:  SLEAP
        source_file:      /home/runner/.movement/data/poses/SLEAP_three-mice_Aeon...




.. GENERATED FROM PYTHON SOURCE LINES 421-424

Indeed we see that in addition to the original data arrays ``pose_tracks``
and ``confidence``, the ``ds`` dataset now also contains data arrays called
``displacement``, ``velocity`` and ``acceleration``.

.. GENERATED FROM PYTHON SOURCE LINES 424-427

.. code-block:: Python


    print(ds.displacement)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    <xarray.DataArray 'displacement' (time: 601, individuals: 3, keypoints: 1,
                                      space: 2)> Size: 14kB
    0.0 0.0 0.0 0.0 0.0 0.0 3.016 ... -0.002655 -1.992 0.9083 -2.725 1.46 -3.175
    Coordinates:
      * time         (time) float64 5kB 0.0 0.02 0.04 0.06 ... 11.96 11.98 12.0
      * individuals  (individuals) <U10 120B 'AEON3B_NTP' 'AEON3B_TP1' 'AEON3B_TP2'
      * keypoints    (keypoints) <U8 32B 'centroid'
      * space        (space) <U1 8B 'x' 'y'




.. GENERATED FROM PYTHON SOURCE LINES 428-430

.. code-block:: Python

    print(ds.velocity)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    <xarray.DataArray 'velocity' (time: 601, individuals: 3, keypoints: 1, space: 2)> Size: 14kB
    150.8 -0.9338 31.21 -114.8 31.2 157.7 ... -99.58 45.42 -136.3 73.02 -158.8
    Coordinates:
      * time         (time) float64 5kB 0.0 0.02 0.04 0.06 ... 11.96 11.98 12.0
      * individuals  (individuals) <U10 120B 'AEON3B_NTP' 'AEON3B_TP1' 'AEON3B_TP2'
      * keypoints    (keypoints) <U8 32B 'centroid'
      * space        (space) <U1 8B 'x' 'y'




.. GENERATED FROM PYTHON SOURCE LINES 431-432

.. code-block:: Python

    print(ds.acceleration)




.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    <xarray.DataArray 'acceleration' (time: 601, individuals: 3, keypoints: 1,
                                      space: 2)> Size: 14kB
    -3.704e+03 -9.766 -5.743e+03 9.864e+03 -663.3 ... -4.158 -8.083e+03 202.3 88.65
    Coordinates:
      * time         (time) float64 5kB 0.0 0.02 0.04 0.06 ... 11.96 11.98 12.0
      * individuals  (individuals) <U10 120B 'AEON3B_NTP' 'AEON3B_TP1' 'AEON3B_TP2'
      * keypoints    (keypoints) <U8 32B 'centroid'
      * space        (space) <U1 8B 'x' 'y'





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 2.105 seconds)


.. _sphx_glr_download_examples_compute_kinematics.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: binder-badge

      .. image:: images/binder_badge_logo.svg
        :target: https://mybinder.org/v2/gh/neuroinformatics-unit/movement/gh-pages?filepath=notebooks/examples/compute_kinematics.ipynb
        :alt: Launch binder
        :width: 150 px

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: compute_kinematics.ipynb <compute_kinematics.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: compute_kinematics.py <compute_kinematics.py>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
